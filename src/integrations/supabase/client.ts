
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { BabyName, NameCategory } from '@/data/types';

const SUPABASE_URL = "https://rwxjdyudnkkehdjdcbtc.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJ3eGpkeXVkbmtrZWhkamRjYnRjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI0MDk1MjksImV4cCI6MjA1Nzk4NTUyOX0.mwGzGBpq2Idv8mRUPH-kAYrFUPptcDf2nbNJ50oNpbQ";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Track a name visit for analytics
export const trackNameVisit = async (nameId: number) => {
  try {
    await supabase
      .from('name_visits')
      .insert({ name_id: nameId });
  } catch (error) {
    console.error('Error tracking name visit:', error);
  }
};

// New functions for fetching baby names from Supabase

export const fetchAllNames = async (): Promise<BabyName[]> => {
  try {
    // Fetch names from the database
    const { data: namesData, error: namesError } = await supabase
      .from('baby_names')
      .select('*');

    if (namesError) throw namesError;

    // Fetch category mappings
    const { data: mappingsData, error: mappingsError } = await supabase
      .from('name_category_mappings')
      .select('name_id, category_id, name_categories(name)')
      .returns<{ name_id: number; category_id: number; name_categories: { name: string } }[]>();

    if (mappingsError) throw mappingsError;

    // Transform the data to match our BabyName interface
    const babyNames: BabyName[] = namesData.map(name => {
      // Find all categories for this name
      const categories = mappingsData
        .filter(mapping => mapping.name_id === name.id)
        .map(mapping => mapping.name_categories.name);

      return {
        id: name.id,
        name: name.name,
        gender: name.gender as 'boy' | 'girl' | 'unisex',
        origin: name.origin,
        meaning: name.meaning,
        popularity: name.popularity,
        length: name.length as 'short' | 'medium' | 'long',
        categories: categories,
        firstLetter: name.first_letter
      };
    });

    return babyNames;
  } catch (error) {
    console.error('Error fetching names:', error);
    throw error;
  }
};

export const fetchCategories = async (): Promise<NameCategory[]> => {
  try {
    const { data, error } = await supabase
      .from('name_categories')
      .select('*');

    if (error) throw error;

    return data.map(category => ({
      id: category.name,
      title: category.title,
      description: category.description || '',
      icon: category.icon || 'crown'
    }));
  } catch (error) {
    console.error('Error fetching categories:', error);
    throw error;
  }
};

export const fetchNameById = async (id: number): Promise<BabyName | null> => {
  try {
    // Fetch the name
    const { data: name, error: nameError } = await supabase
      .from('baby_names')
      .select('*')
      .eq('id', id)
      .single();

    if (nameError) throw nameError;

    // Fetch categories for this name
    const { data: mappings, error: mappingsError } = await supabase
      .from('name_category_mappings')
      .select('name_categories(name)')
      .eq('name_id', id)
      .returns<{ name_categories: { name: string } }[]>();

    if (mappingsError) throw mappingsError;

    // Transform to BabyName format
    const categories = mappings.map(mapping => mapping.name_categories.name);

    return {
      id: name.id,
      name: name.name,
      gender: name.gender as 'boy' | 'girl' | 'unisex',
      origin: name.origin,
      meaning: name.meaning,
      popularity: name.popularity,
      length: name.length as 'short' | 'medium' | 'long',
      categories: categories,
      firstLetter: name.first_letter
    };
  } catch (error) {
    console.error('Error fetching name by ID:', error);
    return null;
  }
};

export const fetchNamesByCategory = async (category: string): Promise<BabyName[]> => {
  try {
    // Get the category ID first
    const { data: categoryData, error: categoryError } = await supabase
      .from('name_categories')
      .select('id')
      .eq('name', category)
      .single();

    if (categoryError) throw categoryError;

    // Get all name IDs in this category
    const { data: mappings, error: mappingsError } = await supabase
      .from('name_category_mappings')
      .select('name_id')
      .eq('category_id', categoryData.id);

    if (mappingsError) throw mappingsError;

    if (mappings.length === 0) return [];

    const nameIds = mappings.map(mapping => mapping.name_id);

    // Fetch all these names
    const { data: names, error: namesError } = await supabase
      .from('baby_names')
      .select('*')
      .in('id', nameIds);

    if (namesError) throw namesError;

    // We need all categories for each name
    const { data: allMappings, error: allMappingsError } = await supabase
      .from('name_category_mappings')
      .select('name_id, name_categories(name)')
      .in('name_id', nameIds)
      .returns<{ name_id: number; name_categories: { name: string } }[]>();

    if (allMappingsError) throw allMappingsError;

    // Transform to BabyName format
    return names.map(name => {
      const categories = allMappings
        .filter(mapping => mapping.name_id === name.id)
        .map(mapping => mapping.name_categories.name);

      return {
        id: name.id,
        name: name.name,
        gender: name.gender as 'boy' | 'girl' | 'unisex',
        origin: name.origin,
        meaning: name.meaning,
        popularity: name.popularity,
        length: name.length as 'short' | 'medium' | 'long',
        categories: categories,
        firstLetter: name.first_letter
      };
    });
  } catch (error) {
    console.error('Error fetching names by category:', error);
    return [];
  }
};

export const fetchPopularNames = async (
  gender?: 'boy' | 'girl' | 'unisex',
  limit = 10
): Promise<BabyName[]> => {
  try {
    let query = supabase
      .from('baby_names')
      .select('*')
      .order('popularity', { ascending: false });

    if (gender) {
      query = query.eq('gender', gender);
    }

    if (limit) {
      query = query.limit(limit);
    }

    const { data: names, error: namesError } = await query;

    if (namesError) throw namesError;

    // Get categories for these names
    const nameIds = names.map(name => name.id);

    const { data: mappings, error: mappingsError } = await supabase
      .from('name_category_mappings')
      .select('name_id, name_categories(name)')
      .in('name_id', nameIds)
      .returns<{ name_id: number; name_categories: { name: string } }[]>();

    if (mappingsError) throw mappingsError;

    // Transform to BabyName format
    return names.map(name => {
      const categories = mappings
        .filter(mapping => mapping.name_id === name.id)
        .map(mapping => mapping.name_categories.name);

      return {
        id: name.id,
        name: name.name,
        gender: name.gender as 'boy' | 'girl' | 'unisex',
        origin: name.origin,
        meaning: name.meaning,
        popularity: name.popularity,
        length: name.length as 'short' | 'medium' | 'long',
        categories: categories,
        firstLetter: name.first_letter
      };
    });
  } catch (error) {
    console.error('Error fetching popular names:', error);
    return [];
  }
};

export const searchNames = async (query: string): Promise<BabyName[]> => {
  try {
    const searchTerm = `%${query.toLowerCase()}%`;

    const { data: names, error: namesError } = await supabase
      .from('baby_names')
      .select('*')
      .or(`name.ilike.${searchTerm},meaning.ilike.${searchTerm},origin.ilike.${searchTerm}`);

    if (namesError) throw namesError;

    if (names.length === 0) return [];

    // Get categories for these names
    const nameIds = names.map(name => name.id);

    const { data: mappings, error: mappingsError } = await supabase
      .from('name_category_mappings')
      .select('name_id, name_categories(name)')
      .in('name_id', nameIds)
      .returns<{ name_id: number; name_categories: { name: string } }[]>();

    if (mappingsError) throw mappingsError;

    // Transform to BabyName format
    return names.map(name => {
      const categories = mappings
        .filter(mapping => mapping.name_id === name.id)
        .map(mapping => mapping.name_categories.name);

      return {
        id: name.id,
        name: name.name,
        gender: name.gender as 'boy' | 'girl' | 'unisex',
        origin: name.origin,
        meaning: name.meaning,
        popularity: name.popularity,
        length: name.length as 'short' | 'medium' | 'long',
        categories: categories,
        firstLetter: name.first_letter
      };
    });
  } catch (error) {
    console.error('Error searching names:', error);
    return [];
  }
};
