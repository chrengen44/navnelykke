// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { BabyName, NameCategory } from '@/data/types';

const SUPABASE_URL = "https://rwxjdyudnkkehdjdcbtc.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJ3eGpkeXVkbmtrZWhkamRjYnRjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI0MDk1MjksImV4cCI6MjA1Nzk4NTUyOX0.mwGzGBpq2Idv8mRUPH-kAYrFUPptcDf2nbNJ50oNpbQ";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Track a name visit for analytics
export const trackNameVisit = async (nameId: number) => {
  try {
    await supabase
      .from('name_visits')
      .insert({ name_id: nameId });
  } catch (error) {
    console.error('Error tracking name visit:', error);
  }
};

// Batch upload baby names
export const batchInsertNames = async (names: {
  name: string;
  gender: 'boy' | 'girl' | 'unisex';
  origin: string;
  meaning: string;
  popularity: number;
  length: 'short' | 'medium' | 'long';
  categories: string[];
  firstLetter: string;
}[]): Promise<{ success: boolean; inserted: number; errors: any[] }> => {
  const errors: any[] = [];
  let inserted = 0;
  
  try {
    // Process in batches of 50 to avoid request size limits
    for (let i = 0; i < names.length; i += 50) {
      const batch = names.slice(i, i + 50);
      
      // First, insert the names
      const nameRecords = batch.map(name => ({
        name: name.name,
        gender: name.gender,
        origin: name.origin,
        meaning: name.meaning,
        popularity: name.popularity,
        length: name.length,
        first_letter: name.firstLetter
      }));
      
      const { data: insertedNames, error } = await supabase
        .from('baby_names')
        .insert(nameRecords)
        .select();
      
      if (error) {
        errors.push({ batch: i, error });
        console.error('Error inserting names batch:', error);
        continue;
      }
      
      // Then, add category mappings for each name
      for (let j = 0; j < insertedNames.length; j++) {
        const nameId = insertedNames[j].id;
        const nameCategories = batch[j].categories;
        
        // Fetch category IDs by name
        const { data: categoryData, error: categoryError } = await supabase
          .from('name_categories')
          .select('id, name')
          .in('name', nameCategories);
        
        if (categoryError) {
          errors.push({ nameId, error: categoryError });
          console.error('Error fetching categories for name:', nameId, categoryError);
          continue;
        }
        
        // Create category mappings
        const categoryMappings = categoryData.map(category => ({
          name_id: nameId,
          category_id: category.id
        }));
        
        if (categoryMappings.length > 0) {
          const { error: mappingError } = await supabase
            .from('name_category_mappings')
            .insert(categoryMappings);
          
          if (mappingError) {
            errors.push({ nameId, error: mappingError });
            console.error('Error inserting category mappings for name:', nameId, mappingError);
          }
        }
      }
      
      inserted += insertedNames.length;
      console.log(`Inserted batch ${i/50 + 1}/${Math.ceil(names.length/50)}, ${inserted}/${names.length} names so far`);
    }
    
    return { 
      success: errors.length === 0, 
      inserted,
      errors 
    };
  } catch (error) {
    console.error('Error in batch insert operation:', error);
    return { 
      success: false, 
      inserted,
      errors: [...errors, error] 
    };
  }
};

// New functions for fetching baby names from Supabase

export const fetchAllNames = async (): Promise<BabyName[]> => {
  try {
    // Fetch names from the database
    const { data: namesData, error: namesError } = await supabase
      .from('baby_names')
      .select('*');

    if (namesError) throw namesError;

    // Fetch category mappings
    const { data: mappingsData, error: mappingsError } = await supabase
      .from('name_category_mappings')
      .select('name_id, category_id, name_categories(name)')
      .returns<{ name_id: number; category_id: number; name_categories: { name: string } }[]>();

    if (mappingsError) throw mappingsError;

    // Transform the data to match our BabyName interface
    const babyNames: BabyName[] = namesData.map(name => {
      // Find all categories for this name
      const categories = mappingsData
        .filter(mapping => mapping.name_id === name.id)
        .map(mapping => mapping.name_categories.name);

      return {
        id: name.id,
        name: name.name,
        gender: name.gender as 'boy' | 'girl' | 'unisex',
        origin: name.origin,
        meaning: name.meaning,
        popularity: name.popularity,
        length: name.length as 'short' | 'medium' | 'long',
        categories: categories,
        firstLetter: name.first_letter
      };
    });

    return babyNames;
  } catch (error) {
    console.error('Error fetching names:', error);
    throw error;
  }
};

export const fetchCategories = async (): Promise<NameCategory[]> => {
  try {
    const { data, error } = await supabase
      .from('name_categories')
      .select('*');

    if (error) throw error;

    return data.map(category => ({
      id: category.name,
      title: category.title,
      description: category.description || '',
      icon: category.icon || 'crown'
    }));
  } catch (error) {
    console.error('Error fetching categories:', error);
    throw error;
  }
};

export const fetchNameById = async (id: number): Promise<BabyName | null> => {
  try {
    console.log('Fetching name with ID:', id);
    
    // Fetch the name
    const { data: name, error: nameError } = await supabase
      .from('baby_names')
      .select('*')
      .eq('id', id)
      .single();

    if (nameError) {
      console.error('Error fetching name:', nameError);
      throw nameError;
    }
    
    if (!name) {
      console.log('No name found with ID:', id);
      return null;
    }

    console.log('Name data retrieved:', name);

    // Fetch categories for this name
    const { data: mappings, error: mappingsError } = await supabase
      .from('name_category_mappings')
      .select('name_categories(name)')
      .eq('name_id', id);

    if (mappingsError) {
      console.error('Error fetching categories:', mappingsError);
      throw mappingsError;
    }

    // Transform to BabyName format
    const categories = mappings.map(mapping => mapping.name_categories.name);

    return {
      id: name.id,
      name: name.name,
      gender: name.gender as 'boy' | 'girl' | 'unisex',
      origin: name.origin,
      meaning: name.meaning,
      popularity: name.popularity,
      length: name.length as 'short' | 'medium' | 'long',
      categories: categories,
      firstLetter: name.first_letter
    };
  } catch (error) {
    console.error('Error fetching name by ID:', error);
    return null;
  }
};

export const fetchNamesByCategory = async (category: string): Promise<BabyName[]> => {
  try {
    // Get the category ID first
    const { data: categoryData, error: categoryError } = await supabase
      .from('name_categories')
      .select('id')
      .eq('name', category)
      .single();

    if (categoryError) throw categoryError;

    // Get all name IDs in this category
    const { data: mappings, error: mappingsError } = await supabase
      .from('name_category_mappings')
      .select('name_id')
      .eq('category_id', categoryData.id);

    if (mappingsError) throw mappingsError;

    if (mappings.length === 0) return [];

    const nameIds = mappings.map(mapping => mapping.name_id);

    // Fetch all these names
    const { data: names, error: namesError } = await supabase
      .from('baby_names')
      .select('*')
      .in('id', nameIds);

    if (namesError) throw namesError;

    // We need all categories for each name
    const { data: allMappings, error: allMappingsError } = await supabase
      .from('name_category_mappings')
      .select('name_id, name_categories(name)')
      .in('name_id', nameIds)
      .returns<{ name_id: number; name_categories: { name: string } }[]>();

    if (allMappingsError) throw allMappingsError;

    // Transform to BabyName format
    return names.map(name => {
      const categories = allMappings
        .filter(mapping => mapping.name_id === name.id)
        .map(mapping => mapping.name_categories.name);

      return {
        id: name.id,
        name: name.name,
        gender: name.gender as 'boy' | 'girl' | 'unisex',
        origin: name.origin,
        meaning: name.meaning,
        popularity: name.popularity,
        length: name.length as 'short' | 'medium' | 'long',
        categories: categories,
        firstLetter: name.first_letter
      };
    });
  } catch (error) {
    console.error('Error fetching names by category:', error);
    return [];
  }
};

export const fetchPopularNames = async (
  gender?: 'boy' | 'girl' | 'unisex',
  limit = 10
): Promise<BabyName[]> => {
  try {
    let query = supabase
      .from('baby_names')
      .select('*')
      .order('popularity', { ascending: false });

    if (gender) {
      query = query.eq('gender', gender);
    }

    if (limit) {
      query = query.limit(limit);
    }

    const { data: names, error: namesError } = await query;

    if (namesError) throw namesError;

    // Get categories for these names
    const nameIds = names.map(name => name.id);

    const { data: mappings, error: mappingsError } = await supabase
      .from('name_category_mappings')
      .select('name_id, name_categories(name)')
      .in('name_id', nameIds)
      .returns<{ name_id: number; name_categories: { name: string } }[]>();

    if (mappingsError) throw mappingsError;

    // Transform to BabyName format
    return names.map(name => {
      const categories = mappings
        .filter(mapping => mapping.name_id === name.id)
        .map(mapping => mapping.name_categories.name);

      return {
        id: name.id,
        name: name.name,
        gender: name.gender as 'boy' | 'girl' | 'unisex',
        origin: name.origin,
        meaning: name.meaning,
        popularity: name.popularity,
        length: name.length as 'short' | 'medium' | 'long',
        categories: categories,
        firstLetter: name.first_letter
      };
    });
  } catch (error) {
    console.error('Error fetching popular names:', error);
    return [];
  }
};

export const searchNames = async (query: string): Promise<BabyName[]> => {
  try {
    const searchTerm = `%${query.toLowerCase()}%`;

    const { data: names, error: namesError } = await supabase
      .from('baby_names')
      .select('*')
      .or(`name.ilike.${searchTerm},meaning.ilike.${searchTerm},origin.ilike.${searchTerm}`);

    if (namesError) throw namesError;

    if (names.length === 0) return [];

    // Get categories for these names
    const nameIds = names.map(name => name.id);

    const { data: mappings, error: mappingsError } = await supabase
      .from('name_category_mappings')
      .select('name_id, name_categories(name)')
      .in('name_id', nameIds)
      .returns<{ name_id: number; name_categories: { name: string } }[]>();

    if (mappingsError) throw mappingsError;

    // Transform to BabyName format
    return names.map(name => {
      const categories = mappings
        .filter(mapping => mapping.name_id === name.id)
        .map(mapping => mapping.name_categories.name);

      return {
        id: name.id,
        name: name.name,
        gender: name.gender as 'boy' | 'girl' | 'unisex',
        origin: name.origin,
        meaning: name.meaning,
        popularity: name.popularity,
        length: name.length as 'short' | 'medium' | 'long',
        categories: categories,
        firstLetter: name.first_letter
      };
    });
  } catch (error) {
    console.error('Error searching names:', error);
    return [];
  }
};
